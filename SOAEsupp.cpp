
// ### SOAEsupp.cpp ###            4/19/06

// code is designed to measure SOAE activity when a
// single external tone is also presented (user specifies
// frequency and level), whose presence is intended to
// 'suppress' a nearby SOAE
 
// used template code 
// C:\cygwin\home\Chris\Cscript\SFOAEcode1\SFOAEmeas1.cpp

// one input file must be specified (a calibration
// file generated by LynxEPcalib.cpp, just for EP1)

#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <math.h>
#include <string.h>   
#include "realft.h"
#include "onedfft.h"

#define PI 3.14159265358979
#define NBUFFERS 6		// double-buffering

HWAVEIN hWaveIn;
HWAVEOUT hWaveOut;
WAVEINCAPS WavInCaps;
WAVEHDR whdri[NBUFFERS];
WAVEHDR whdro[NBUFFERS];
MMRESULT Result;
WAVEFORMATEX wfmt;

FILE *fp;
FILE *fp2;

int main(int argc, char* argv[])
{

  // ------------------------------------------------------------
  // USER PARAMETERS

  // CALIBRATION INFO
  // location of calibration files (for EP1)
  char Cfile1[100]= "../../DATA/09.06.07/AGrear1.EP1.txt";
  // location/filename prefix to save data to
  char nameF[100]= "../../DATA/09.06.07/AGrearSOAEsupp2";  

  // SFOAE PARAMETERS
  double minprobeFreq= 1900.0;   // suppressor freq. (Hz)

  const int Averages= 60;  // # of buffers to obtain for averaging
                     // (time waveforms are what gets averaged)

  double ProbeLevel= -40.0;  // desired suppressor level (dB SPL)

  // ARTIFACT REJECTION CRITERIA
  double maxDEF= 0.4;   // criteria for artifact rejection 
  int maXnoiSe= 1000;   // max. # of rejects (noisy meas.) allowed
                    // (program self-destructs once it reaches this)

  // --------------------------------------------------------------
  // System Parameters (not as likely to be changed)

  long Rate = 44100;   // sample rate (both input and output)

  char SAVE= 'Y';  // saved spectrum to file (Y or N)

  char saveSPSF= 1;       // save?
                          // 1 - SFOAE info (default)
                          // 2 - spectral info (of last freq. -> for debugging)

  char WINDOW= '1';        // type of windowing to be done upon input data
                           // array (in time-domain)                          
                           // 1 - square (i.e. no wondowing)
                           // 2 - 'semi'-Hanning window (cosine, no 0.5 factor) 
                           // 3 - Bartlett window (triangular)
                           // 4 - Welch window ('bump')
   
  double gain0= 40.0;     // ER-10C gain setting

  int NCHAN= 2;           // # of output/input channels (leave at 2)
  int DEVICE= 0;          // device # (default is 0)
  int BYTESPERSAMPLE= 4;  // '4' = 32 bit mode (leave at 4)

  double lynxgain= 1.11;  // kludge fixes due to a hardware gain factor
                         // introduced by the card which I don't know 
                         // how to turn off (1.11 appears to be the 
                         // 'correct' value, though the lynx support
                         // says it should be 1.096)

  const int CBsize= 4097; // # of points in calibration file (was formerly 2899)

  const int TbuffSize= 32768;     // total # of points in input buffer

  const int SAMPLES= 8192;        // # of points in acq. 'window' (must be 2^N),
                                  // the value of 8192 is harwired into the code,
                 // so a change here requires coding changes in stim. definitition

  long nPts = TbuffSize; // do it this way to to problems defing
                       // array sizes using a variable, total # of
                       // points in an acqusition
  int nsamples= nPts; // # of points in acquisition 'window'

  double CalibCheck= 3.0; // dB value for checking how 'off' calibration is

  // ------------------------------------------------------------
  // lower level code variables


  long *waveInBuffer[NBUFFERS];   // buffer to contain data coming in
  long *waveOutBuffer[NBUFFERS];  //   "        "       "   going out
 
  unsigned nPolls[NBUFFERS];
  
  char *program = NULL;
  char errText[MAXERRORLENGTH];
  int error = 0;

  long i, b, n; 
  long *x;  // pointer used to pull out data from card's input buffer

  double gain;  // multiplication factor for ER-10C gain

  int avg; // counter to keep track of # of averages already got

  // AR variables
  long DIFF;  // diff. between reference and current AR buffers
  int flag= 0;
  long *REF;
  int alpha= 0; // counter to keep track of how many noisy meas. occurred

  char name1[100]; // string for filename to save to
  int z= 0;    // counter to keep track of calib. each EP

  long *SineWaveP;   // pointer for ch.1 output sinusoid (to feed out. buff.)
  long *SineWaveS;   // pointer for ch.2 output sinusoid
  double df, dt;  // help quantize freq. so integral #s of periods fit in window
                  // (acquisition window, not total window)
  long maxDEFlong;  // integer to match maxDEF for AR

  double FreqP;   // keep track of current freq.

  double CALIB1[CBsize][3];  // arrays for calibration values

  // ---------------------------------------------------------------
  // declare variables for FFT and allocate memory (and for averaging)
  double *frequency;  // array to hold freq. values
  long *DATA, *DATAb;  // arrays for data to be stored into
  double *DATA2, *DATAb2;
  double *DATAP;  // arrays to store AP-passed window data

  double *AvgWaveP;   // array pointer for averaged waveform (probe)

  double *AvgMagP;    // arrays for output of FFT function
  double *AvgPhaseP;  //         "            "

  double *mag, *phase;  // used for FFT every window for error analysis


  double phaseDp;  // keeps track of 'calibrated' offset phase

  int ff; // counter to keep track of data indexing

  char scanline[4096];  // string variables necessary to
  char sl2[4096];      // properly read in calibration file
  char sl3[4096];

  double amplP;    // output amplitude for EP 1
  int k;  // counter for determining amplitude
  int k0; // const. version of k for keeping track of probe freq. location

 
  if(!(DATA=(long *)malloc(nPts*sizeof(long))))
  {
    perror("couldn't allocate memory DATA");
    exit(1);
  }
 if(!(DATA2=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for DATA2");
    exit(1);
  }
 // the two below are for the second buffer in the AR
  if(!(DATAb=(long *)malloc(nPts*sizeof(long))))
  {
    perror("couldn't allocate memory DATAb");
    exit(1);
  }
 if(!(DATAb2=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for DATAb2");
    exit(1);
  }
if(!(DATAP=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for DATAP");
    exit(1);
  }


 if(!(frequency=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for frequency");
    exit(1);
  }

if(!(AvgMagP=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for AvgMagP");
    exit(1);
  }
if(!(AvgPhaseP=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for AvgPhaseP");
    exit(1);
  }
if(!(mag=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for mag");
    exit(1);
  }
if(!(phase=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for phase");
    exit(1);
  }

 if(!(REF=(long *)malloc(nPts*sizeof(long))))
  {
    perror("couldn't allocate memory for REF");
    exit(1);
  }
 if(!(AvgWaveP=(double *)malloc(nsamples*sizeof(double))))
  {
    perror("couldn't allocate memory for AvgWaveP");
    exit(1);
  }
 

  // allocate memory for sinusoidal output (for both channels)
  SineWaveP = (long *)calloc (nPts, sizeof(long));
  if (!SineWaveP)
    {
      fprintf (stderr, "%s: Memory allocation error.\n", program);
      return (1);
    }

  SineWaveS = (long *)calloc (nPts, sizeof(long));
  if (!SineWaveS)
    {
      fprintf (stderr, "%s: Memory allocation error.\n", program);
      return (1);
    }


  // --------------------------------------------------------------


  program = *argv; // creates a string which is just the executable's
                   // name (used for debugging, not really necessary)
  //fprintf (stdout, "points per acquisition buffer = %d\n", nsamples);
  //fprintf (stdout, "total points per buffer = %d\n", nPts);
  fprintf (stdout, "\nSample rate = %d\n", Rate);
  printf("# of averages to be computed per freq. is %d\n", Averages); 
  // sets the multiplication factor for the input voltage                    
  // if the gain on the ER-10C is set                                 
  if(gain0 == 40.0)
    gain=0.01;
  else if(gain0 == 20.0)
    gain= 0.1;
  else
    gain= 1.0; 

  // create frequency array (for FFT bin labeling)
  for (i = 0; i < nPts; ++i)
    {
      frequency[i]= ((double)Rate*i)/(double)nPts;
    }
 
  // convert maxDEF to the proper integer
  maxDEFlong= (long)(maxDEF*256*pow(2,23)/(lynxgain*10.0));

  // ----------------------------------------------------------
  // READ IN CALIBRATION FILES 


  // read in calibration files
  if(!(fp2= fopen(Cfile1, "r")))
    {
      perror("\nCan not open first calibration file\n");
      exit(1);
    }
  for(i= 0; i < CBsize; i++)
    {
      fscanf(fp2, "%s\t%s\t%s\n", scanline, sl2, sl3);
      CALIB1[i][0]= strtod(scanline, NULL);
      CALIB1[i][1]= strtod(sl2, NULL);
      CALIB1[i][2]= strtod(sl3, NULL);
    }
   fclose(fp2);



   // first column is frequency, second is dB SPL level which would
   // be presented at that freq. is a 1V driving voltage was applied
   // and the last column is the phase shift between input and output
   // during calibration (slope tells you total delay present)
   //printf("%g\t%g\t%g\n", CALIB2[12][0],CALIB2[12][1],CALIB2[12][2]);

  // --------------------------------------------------------------------

  // sets up the I/O buffers and the card for the input and output via
  // the Windows MultiMedia structures
  // waveInOpen ...
  wfmt.wFormatTag = WAVE_FORMAT_PCM;
  wfmt.nChannels = NCHAN;
  wfmt.nSamplesPerSec = Rate;
  wfmt.nAvgBytesPerSec = NCHAN * BYTESPERSAMPLE * Rate;
  wfmt.nBlockAlign = NCHAN * BYTESPERSAMPLE;
  wfmt.wBitsPerSample = BYTESPERSAMPLE * 8;
  wfmt.cbSize = 0;

  Result = waveInOpen(&hWaveIn, DEVICE, &wfmt, 0, 0, 0);
  if (Result)
    {
      waveOutGetErrorText (Result, errText, MAXERRORLENGTH);
      fprintf (stderr, "%s\n", errText);
      return ((int )Result);   
    }


  // waveOutOpen and Pause ...
  wfmt.wFormatTag = WAVE_FORMAT_PCM;
  wfmt.nChannels = NCHAN;
  wfmt.nSamplesPerSec = Rate;
  wfmt.nAvgBytesPerSec = NCHAN * BYTESPERSAMPLE * Rate;
  wfmt.nBlockAlign = NCHAN * BYTESPERSAMPLE;
  wfmt.wBitsPerSample = BYTESPERSAMPLE * 8;
  wfmt.cbSize = 0;

  Result = waveOutOpen(&hWaveOut, DEVICE, &wfmt, 0, 0, WAVE_ALLOWSYNC);
  if (Result)
    {
      waveOutGetErrorText (Result, errText, MAXERRORLENGTH);
      fprintf (stderr, "%s\n", errText);
      return ((int )Result);
    }

  //waveOutPause(hWaveOut);
  waveInGetDevCaps ((int )hWaveIn, &WavInCaps, sizeof(WAVEINCAPS));
  //fprintf(stdout, "%s\n", WavInCaps.szPname);


  // Allocate buffers and prepare headers ...

  // NOTE: the NBUFFERS is the # of buffers which the code uses in the
  // circular buffering paradigm, thus you need to allocate for all


  for (b = 0; b < NBUFFERS; ++b)
    {
      waveInBuffer[b] = (long *)calloc (nPts, NCHAN*BYTESPERSAMPLE);
      waveOutBuffer[b] = (long *)calloc (nPts, NCHAN*BYTESPERSAMPLE);
      if (!waveInBuffer[b] || !waveOutBuffer[b]) 
	{
	  fprintf (stderr, "%s: Memory allocation error.\n", program);
	  return (1);
	}

      // you don't pass data directly to the card, but via structures,  
      // the commands below spell out the form of those structures

      // Prepare waveOut headers ...
      whdro[b].lpData = (HPSTR) waveOutBuffer[b];
      whdro[b].dwBufferLength = nPts * NCHAN * BYTESPERSAMPLE;
      whdro[b].dwFlags = 0;
      whdro[b].dwLoops = 0;
      waveOutPrepareHeader(hWaveOut, &whdro[b], sizeof(WAVEHDR));

      // Prepare waveIn headers ...
      whdri[b].lpData = (HPSTR) waveInBuffer[b];
      whdri[b].dwBufferLength = nPts * NCHAN * BYTESPERSAMPLE;
      whdri[b].dwFlags = 0;
      whdri[b].dwLoops = 0;
      waveInPrepareHeader(hWaveIn, &whdri[b], sizeof(WAVEHDR));

    }  // end of loop to set up buffers/headers

  printf("\n");


      // pause output (guarentees I/O synchonity, ...sp?)
      waveOutPause(hWaveOut); 
       
      // -----------------------------------------------------------
      // Create stimuli and send to output buffers
      
      // set the frequency 
	FreqP= minprobeFreq;
 
      
      // quantize the frequency so that the stimulus is periodic, this ensures
      // an integral # of periods to fit into the acquistion window (but not the   
      // entire window) well, makes it pretty close to being so
      df = ((double )Rate) / ((double )(nsamples));
      dt = 1./((double )Rate);
      FreqP = ceil (FreqP/df) * df;
      printf("---------------------------------------------------\n");
      fprintf (stdout, "\nactual ch. 1 output frequency is =%g\n", FreqP);

      
      // search spectrum for probe freq. and pull out relevant values
      k= 1;
      while(FreqP >= frequency[k])
	{
	  k++;
	}
      k0= k-1;  // should be -1
      
      // determine amplitudes necessary from calibration file (assumes
      // earphone linearity, see bottom of code for descript.)
      // NOTE: no interpolation is necessary (coding has been removed)             
      k= 1;
      for(i= 0; i < CBsize; i++) 
	{
	  if( (FreqP-CALIB1[k][0]) < 0.01)
	    {
	      amplP= CALIB1[k][1];   // if the freq. is one in the array             
	      phaseDp= CALIB1[k][2]; 
	      k=k+1;
	      break;   // break since you got the value you need         
	    }
	  else      // move on to the next frequency element if necessary  
	    k= k+1;
	}
      
      // find dB difference and convert to a voltage factor, this really
      // is amplP [V]= 1 V * pow(...)   where pow(...) is the factor to increase the
      // voltage (thus it is dimension-less), thus the calibration file is really
      // telling you what level dB SPL
      // you will get for a given tone if you drive it at 1 V 
      amplP= pow(10,(ProbeLevel-amplP)/20);
      

      
      printf("\nProbe Level= %g dB (%g V)\n\n", 
	     ProbeLevel, amplP);
      
      // CHECK TO MAKE SURE VOLTAGE IS IN OUTPUT BOUNDS
      if(amplP > 10.96)
	{
	  fprintf(stderr,"\n\n************** ERROR ***********************\n");
	  fprintf(stderr,"Amplitude is outside card's output range! \n");
	  exit(1);
	}
      
      // see bottom of code for description of here
      // **NOTE**: output has zero phase at buffer start
      // **NOTE**: use cos instead of sin so that phase is zero relative
      //           to FFT output
      for (i = 0; i < nPts; ++i)
	{
	  // supp. tone is always on
	  SineWaveP[i]= (long) (((amplP/lynxgain) * cos(2*PI*FreqP*i*dt)) 
				* pow(2,31)/10.0);

	  // channel for EP2 is just all zeroes
	  SineWaveS[i]= 0;  
	  
	  //check output (type > Debug/SFOAEmeas1 > junk.txt)
	  //printf("%d\t%g\t%g\n", i, (SineWaveP[i]/256)*10.0/pow(2,23)*lynxgain, 
	  //	                  (SineWaveS[i]/256)*10.0/pow(2,23)*lynxgain);
	  
	}
      
      //printf("first phase delay is %g\n",  fmod((2*PI*FreqP*1023/Rate),2*PI));
      //printf("second phase delay is %g\n",  fmod((2*PI*FreqP*11263/Rate),2*PI));
 
      // write to output buffers
      for (b = 0; b < NBUFFERS; ++b)
	{
	  long *p = waveOutBuffer[b];
	  for (i = 0; i < nPts; ++i)
	    {
	      *p++ = SineWaveP[i];  
	      *p++ = SineWaveS[i];
	    }
	}
      
      for (b = 0; b < NBUFFERS; ++b)
	nPolls[b] = 0;
      
      // write the first NBUFFERS-1 buffer to the devices ...
      for (b = 0; b < NBUFFERS-1; ++b)
	{
	  waveOutWrite(hWaveOut, &whdro[b], sizeof(WAVEHDR));
	  waveInAddBuffer(hWaveIn, &whdri[b], sizeof(WAVEHDR));
	}
      
      // synchronously start all I/O ... (CIRCULAR BUFFERING) *****
      waveOutRestart(hWaveOut);
      waveInStart(hWaveIn);
      
      n= 0; // initialize loop variables
      avg= 0;
      
      // begin the averaging loop ...
      while(avg < Averages) // I
	{
	  
	  // very first buffer is junk, so we toss it out
	  if (n == 0)
	    {
	      int br = n % NBUFFERS;   // next buffer to read (now playing)
	      int bw = (n + NBUFFERS - 1) % NBUFFERS;  // next buffer to write
	      
	      // write next buffer and queue it for playback ...
	      waveOutWrite(hWaveOut, &whdro[bw], sizeof(WAVEHDR));
	      waveInAddBuffer(hWaveIn, &whdri[bw], sizeof(WAVEHDR));
	      
	      // poll the buffer now playing until it's done ...
	      while (!((whdri[br].dwFlags & WHDR_DONE) && 
		       (whdro[br].dwFlags & WHDR_DONE)))
		{
		  ++nPolls[br];
		}
	      n++;
	    }
	  
	  
	  // now for all buffers beyond the first one ........
	  else  // II
	    {
	      // we first need one initial reference buffer for AR
	      if(avg == 0)  // III
		{
		  // grab the first two input buffer-loads and compare
		  do  // bb
		    {
		      flag= 0;  // initialize flag
		      // read in one buffer
		      int br = n % NBUFFERS;	       
		      int bw = (n + NBUFFERS - 1) % NBUFFERS;      
		      // write next buffer and queue it for playback ...
		      waveOutWrite(hWaveOut, &whdro[bw], sizeof(WAVEHDR));
		      waveInAddBuffer(hWaveIn, &whdri[bw], sizeof(WAVEHDR));
		      
		      // poll the buffer now playing until it's done ...
		      while (!((whdri[br].dwFlags & WHDR_DONE) && 
			       (whdro[br].dwFlags & WHDR_DONE)))
			{
			  ++nPolls[br];
			}
		      
		      // we're done recording, so read the data 
		      x = waveInBuffer[br];  // x is a pointer to data location
		      // grab digital input values using pointer x
		      for(i= 0; i < nPts; i++)
			{
			  DATA[i]= *x;
			  x += 2; // increments twice so to ignore input ch. 2 
			}

		      n++; // increment buffer counter (so to look at the next one) 
   
		      // now repeat and read in a second buffer full of data
		      br = n % NBUFFERS;	       
		      bw = (n + NBUFFERS - 1) % NBUFFERS;      
		      waveOutWrite(hWaveOut, &whdro[bw], sizeof(WAVEHDR));
		      waveInAddBuffer(hWaveIn, &whdri[bw], sizeof(WAVEHDR));
		      
		      while (!((whdri[br].dwFlags & WHDR_DONE) && 
			   (whdro[br].dwFlags & WHDR_DONE)))
			{
			  ++nPolls[br];
			}
		      x = waveInBuffer[br];  
		      
		      for(i= 0; i < nPts; i++)
			{
			  DATAb[i]= *x;
			  x += 2; 
			}
		      n++;  // increment buff. counter
		      
		      // -----------------------------------------------------------
		      // now compare the two buffers to see if they satisfy the AR 
		      // criteria
		      
		      // subtract both arrays to get the difference and see if there
		      // is a value which exceeds the criteria
		      for(i= 0; i < nPts; i++)
			{
			  DIFF= (long)(fabs(DATA[i] - DATAb[i]));
			  
			  if(DIFF >= maxDEFlong)
			    flag= 1;  // flag raised if there is a bad meas.
			}	  
		      
		      if(flag == 1) // didnt pass
			{
			  alpha++;
			  printf("\nNoisy Measurement - Redo (%d/%d) \n", 
				 alpha, maXnoiSe);
			}
		      else  // passed
			{
			  // set reference array to the first buffer (probe alone)
			  for(i= 0; i < nPts; i++)
			    {
			      REF[i]= DATA[i];
			    }



			  ff= 0;  // need counter to get correct index 
			  for(i= 0; i < nPts; i++)
			    {
			      DATAP[ff]= ((DATA[i]/256)*10.0/pow(2,23))*lynxgain;
			      ff++;
			    } 


			}
		    } // bb
		  while(flag >= 1);
		}   // (III)
	      
	      // now do the same comparison now that we have one initial 
	      // reference buffer
	      
	      else  // (IV)
		{
		  // only need to grab one buffer now
		  do
		    {
		      
		      // first check to see if too many noisy meas. have been made
		      if (alpha >= maXnoiSe)
			{
			  printf("\nToo many noisy meas.: increase threshold\n");
			  exit(1);
			}
		      
		      flag= 0;  // initialize flag
		      
		      int br = n % NBUFFERS;	       
		      int bw = (n + NBUFFERS - 1) % NBUFFERS;      
		      waveOutWrite(hWaveOut, &whdro[bw], sizeof(WAVEHDR));
		      waveInAddBuffer(hWaveIn, &whdri[bw], sizeof(WAVEHDR));
		      
		      while (!((whdri[br].dwFlags & WHDR_DONE) && 
			       (whdro[br].dwFlags & WHDR_DONE)))
			{
			  ++nPolls[br];
			}
		      // grab entire window
		      x = waveInBuffer[br];  
		      for(i= 0; i < nPts; i++)
			{
			  DATA[i]= *x;
			  x += 2; 
			}
		      n++;  // increment buff. counter
		      
		      // check to see if it passes
		      for(i= 0; i < nPts; i++)
			{
			  DIFF= (long) (fabs(DATA[i] - REF[i]));
			  
			  if(DIFF >= maxDEFlong)
			    flag= 1;  
			}	  
		      
		      if(flag == 1) // didnt pass
			{
			  alpha++;
			  printf("\nNoisy Measurement - Redo (%d/%d)\n",
				 alpha, maXnoiSe);
			}
		      else  // passed
			{
			  // reset reference array 
			  for(i= 0; i < nPts; i++)
			    {
			      REF[i]= DATA[i];
			    }

			  // rename (artifact of old code), besides I need to
			  // convert values to units of pascals (pressure) from
			  // the 24 bit depth #s
			  ff= 0;
			  for(i= 0; i < nPts; i++)
			    {
			      DATAP[ff]= ((DATA[i]/256)*10.0/pow(2,23))*lynxgain;
			      ff++;
			    } 	  

			}
		    }
		  while(flag >= 1);
		}   // (IV)
	      
	      // ---------------------------------------------------
	      // below here only applies once we have an artifact free buff.	  
	      
	      // apply the windowing to the data if specified  	  
	      if(WINDOW == '1')
		{
		  // do nothing to data in time domain for square window     
		}
	      else if(WINDOW == '2')
		{
		  for(i= 0; i < nsamples; i++)  // 'semi'-Hanning window 
		    {                  
		      DATAP[i]= DATAP[i]*(1 - cos(2*PI*i/nsamples));  

		    }     // got rid of the 0.5 factor                       
		}
	      else if(WINDOW == '3')
		{
		  for(i= 0; i < nsamples; i++) // Bartlett window  
		    {
		      DATAP[i]= DATAP[i] * (1 - fabs((i - 0.5*nsamples)
						 /(0.5*nsamples)));

		    }                                                 
		}
	      else if(WINDOW == '4')
		{
		  for(i= 0; i < nsamples; i++)  // Welch window
		    {
		      DATAP[i]= DATAP[i] * (1 - pow( ((i - 0.5*nsamples)/
						  (0.5*nsamples)), 2));

		    }                                                         
		}
	      

	      
	      // print (some) data to screen (debugging) 
	      for(i= 0; i < 20; i++)
		{
		  //printf("%g\n", DATAP[i]);	  
		}
      
	      // FFT data buffer to get spectrum
	      onedfft(DATAP, mag, phase, nsamples);


	      // now average the spectra (ignore phase, only look at mag)
	      if(avg == 0)
		{
		  for(i= 0; i < nsamples; i++)
		    {
		      AvgWaveP[i]= mag[i]/Averages;  

		    }
		}
	      else
		{
		  for(i= 0; i < nsamples; i++)
		    {
		      AvgWaveP[i]= AvgWaveP[i] + mag[i]/Averages;

		    }
		}


	      avg++;  // increment average counter
	      // keep track on screen of how many averages done
	      if (avg == 1)
		printf("Averages done (of %d): %d ", Averages, avg);
	      else
		printf("%d ", avg); 
	      
	    }  // end of cond. else loop (II)
	  
	} // end of averaging loop (I)
      
      printf("\n**DONE**\n\n");

      // now that the averaged time waveform has been obtained,
      // FFT data to get magnitude and phase
      //onedfft(AvgWaveP, AvgMagP, AvgPhaseP, nsamples);
      //onedfft(AvgWavePS, AvgMagPS, AvgPhasePS, nsamples);
      
 

      // reset card for next round (guarentees synchronous I/O)
      waveOutReset(hWaveOut);
      waveInReset(hWaveIn);

      // save data to file if specified, (include mag. and phase)
      if(SAVE == 'Y')
	{
	  // create total file name
	  sprintf(name1, "%s.txt", nameF);
	  
	    {    
	      // ** for saving spectra ** (maninly for debugging)	  
	      // first convert magnitudes to dB SPL
	      for(i= 0; i < nsamples; i++)
		{
		  AvgMagP[i]= 20*log10(AvgWaveP[i]*gain/(pow(10,-6)*sqrt(2)));
		}
	      fp= fopen(name1, "w");
	      // only save lower freq. information (can change denominator
	      // here in loop counter to shift upper limit)
	      for(i= 0; i < nPts/3; i++)
		{
		  fprintf(fp, "%g\t%g\n", frequency[i], AvgMagP[i]);
		}
	      fclose(fp);
	      printf("\n\nfile %s has been saved\n", name1);
	    }

	}    // end of save loop
	  
      //printf(" --------------------------------------------------- \n");

  
      
  // -----------------------------------------------------------
      

  printf("\n --------------------------------------------------------- \n");


  
  // ------------------------------------------------------------

  // clean up ...
  //waveOutReset(hWaveOut);
  //waveInReset(hWaveIn);

  // free up buffers
  for (b = 0; b < NBUFFERS; ++b)
    {
      waveInUnprepareHeader(hWaveIn, &whdri[b], sizeof(WAVEHDR));
      free (waveInBuffer[b]);
     
      waveOutUnprepareHeader(hWaveOut, &whdro[b], sizeof(WAVEHDR));
      free (waveOutBuffer[b]);
    }

  waveOutClose(hWaveOut);
  waveInClose(hWaveIn);

  return (0);
}



